<?php

namespace App\Models;

use Illuminate\Support\Str;
use Laravel\Jetstream\HasTeams;
use Laravel\Sanctum\HasApiTokens;
use App\Models\Scopes\Searchable;
use Laravel\Jetstream\HasProfilePhoto;
use Illuminate\Notifications\Notifiable;
use Laravel\Fortify\TwoFactorAuthenticatable;
use Illuminate\Database\Eloquent\SoftDeletes;
use Illuminate\Contracts\Auth\MustVerifyEmail;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Mainul\CustomHelperFunctions\Helpers\CustomHelper;
use Uzzal\Acl\Traits\AccessControlled;

class User extends Authenticatable
{
    use Notifiable;
    use HasFactory;
    use Searchable;
    use SoftDeletes;
    use HasApiTokens;
    use HasProfilePhoto;
    use TwoFactorAuthenticatable;
    use HasTeams;
    use AccessControlled;

    protected $fillable = [
        'user_id',
        'name',
        'email',
        'password',
        'mobile',
        'user_type',
        'profile_image',
        'provider',
        'provider_token',
        'provider_id',
        'username',
        'approved_by',
        'approve_status',
        'block_status',
        'created_by',
        'reffered_agent_url',
        'reffer_code',
        'ref_influencer_count',
        'affiliate_badge_id',
        'has_infl_partner_access',
        'is_super_dev',
        'user_slug',
    ];

    protected $searchableFields = ['*'];

    protected $hidden = [
        'password',
        'remember_token',
        'two_factor_secret',
        'two_factor_recovery_codes',
    ];

    protected $casts = [
        'email_verified_at' => 'datetime',
        'two_factor_confirmed_at' => 'datetime',
    ];

    protected static function boot()
    {
        parent::boot(); // TODO: Change the autogenerated stub
        static::deleting(function ($user) {
            if (file_exists($user->profile_image)) {
                unlink($user->profile_image);
            }
        });
    }

    protected static function booted()
    {
        parent::booted(); // TODO: Change the autogenerated stub
        static::creating(function ($user) {
            if (empty($user->username)) {
                $user->generateUniqueUsername();
            }
        });
    }

    public static function createUseronOAuth($oAuthUser, $provider, $userType)
    {
        return User::create([
            'name'          => $oAuthUser->name,
            'email'         => $oAuthUser->email,
//                'password'      => Hash::make(Str::random(8)),
            'provider' => $provider,
            'provider_id'   => $oAuthUser->id,
            'provider_token' => $oAuthUser->token,
            'user_slug'     => str_replace(' ', '-', $oAuthUser->name),
            'user_type'     => $userType,
            'profile_image'     => $oAuthUser->getAvatar(),
        ]);
    }

    public static function createOrUpdateUser($request, $user = null)
    {
        return User::updateOrCreate(['id' => $user?->id], [
        'user_id' => $request->user_id ?? $user?->user_id,
        'name' => $request->name ?? $user?->name,
        'email' => $request->email ?? $user?->email,
        'password' => $request->has('password') ? bcrypt($request->password) : $user?->password,
        'mobile' => $request->mobile ?? $user?->mobile,
        'user_type' => $request->user_type ?? $user?->user_type,
        'profile_image' => CustomHelper::fileUpload($request->file('profile_image'), 'user-image', 'user', $user?->profile_image ?? null) ,
        'username' => $request->username ?? $user?->username,
        'approved_by' => $request->approved_by ?? $user?->approved_by,
//        'approve_status' => $request->approve_status ?? $user?->approve_status,
        'block_status' => $request->block_status ?? $user?->block_status,
        'created_by' => $request->created_by ?? $user?->created_by,
        'reffered_agent_url' => $request->reffered_agent_url ?? $user?->reffered_agent_url,
        'reffer_code' => $request->reffer_code ?? $user?->reffer_code,
        'ref_influencer_count' => $request->ref_influencer_count ?? $user?->ref_influencer_count,
        'affiliate_badge_id' => $request->affiliate_badge_id ?? $user?->affiliate_badge_id,
        'has_infl_partner_access' => $request->user_type == 'partner' || $user?->user_type == 'partner' ? 1 : 0,
        'user_slug' => Str::slug($request->name, '-'),
    ]);

    }


    public function generateUniqueUsername()
    {
        // Start with the base username from the name or email
        $baseUsername = $this->username ?? $this->name ?? explode('@', $this->email)[0];

        // Clean the base username: lowercase, remove spaces and special characters
        $baseUsername = strtolower($baseUsername);
        $baseUsername = preg_replace('/[^a-z0-9_]/', '', str_replace(' ', '_', $baseUsername));

        // Ensure it's not empty
        if (empty($baseUsername)) {
            $baseUsername = 'user';
        }

        // Check if the base username is unique
        $username = $baseUsername;
        $counter = 1;

        // Keep adding numbers until we find a unique username
        while (static::where('username', $username)->where('id', '!=', $this->id ?? 0)->exists()) {
            $username = $baseUsername . $counter;
            $counter++;
        }

        // Set and return the unique username
        $this->username = $username;
        return $username;
    }

    public function agentUser()
    {
        return $this->belongsTo(User::class, 'user_id');
    }

    public function influencers()
    {
        return $this->hasMany(User::class, 'user_id');
    }

    public function userInfo()
    {
        return $this->hasOne(UserInfo::class);
    }

    public function createdBy()
    {
        return $this->belongsTo(User::class, 'created_by');
    }

    public function createdByUsers()
    {
        return $this->hasMany(User::class, 'created_by');
    }

    public function createdBanks()
    {
        return $this->hasMany(Bank::class, 'created_by');
    }

    public function userBankInfos()
    {
        return $this->hasMany(UserBankInfo::class);
    }

    public function createdBenefitListCategories()
    {
        return $this->hasMany(BenefitListCategory::class, 'created_by');
    }

    public function deletedBenefitListCategories2()
    {
        return $this->hasMany(BenefitListCategory::class, 'deleted_by');
    }

    public function affiliateBadge()
    {
        return $this->belongsTo(AffiliateBadge::class);
    }

    public function userBadgeHistories()
    {
        return $this->hasMany(UserBadgeHistory::class);
    }

    public function affiliateCodes()
    {
        return $this->hasMany(AffiliateCode::class, 'created_by');
    }

    public function influencerCampains()
    {
        return $this->hasMany(InfluencerCampain::class, 'created_by');
    }

    public function giveawayProductRequirementRequestedUsers()
    {
        return $this->hasMany(
            GiveawayProductRequirement::class,
            'requested_user_id'
        );
    }

    public function giveawayProductRequirementAdminViewers()
    {
        return $this->hasMany(
            GiveawayProductRequirement::class,
            'admin_viewer_id'
        );
    }

    public function giveawayProductRequirementApprovedByUsers()
    {
        return $this->hasMany(GiveawayProductRequirement::class, 'approver_id');
    }

    public function approvedBy()
    {
        return $this->hasOne(User::class, 'approved_by');
    }

    public function approvedByUser()
    {
        return $this->belongsTo(User::class, 'approved_by');
    }

    public function isSuperAdmin(): bool
    {
        return in_array($this->email, config('auth.super_admins'));
    }


//    role relations
    public function roles()
    {
        return $this->belongsToMany(Role::class, 'user_roles', 'user_id', 'role_id');
    }
    public function getUserRoles(){
        return $this->hasMany(UserRole::class, 'user_id','id');
    }

}
